// Code generated by mockery v2.46.0. DO NOT EDIT.

package mocks

import (
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"

	json "encoding/json"

	mock "github.com/stretchr/testify/mock"

	proto "github.com/cosmos/gogoproto/proto"

	tx "github.com/cosmos/cosmos-sdk/types/tx"

	types "github.com/cometbft/cometbft/abci/types"
)

// CodecInterface is an autogenerated mock type for the CodecInterface type
type CodecInterface struct {
	mock.Mock
}

type CodecInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *CodecInterface) EXPECT() *CodecInterface_Expecter {
	return &CodecInterface_Expecter{mock: &_m.Mock}
}

// IsTypedEvent provides a mock function with given fields: event
func (_m *CodecInterface) IsTypedEvent(event *types.Event) bool {
	ret := _m.Called(event)

	if len(ret) == 0 {
		panic("no return value specified for IsTypedEvent")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(*types.Event) bool); ok {
		r0 = rf(event)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// CodecInterface_IsTypedEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsTypedEvent'
type CodecInterface_IsTypedEvent_Call struct {
	*mock.Call
}

// IsTypedEvent is a helper method to define mock.On call
//   - event *types.Event
func (_e *CodecInterface_Expecter) IsTypedEvent(event interface{}) *CodecInterface_IsTypedEvent_Call {
	return &CodecInterface_IsTypedEvent_Call{Call: _e.mock.On("IsTypedEvent", event)}
}

func (_c *CodecInterface_IsTypedEvent_Call) Run(run func(event *types.Event)) *CodecInterface_IsTypedEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.Event))
	})
	return _c
}

func (_c *CodecInterface_IsTypedEvent_Call) Return(_a0 bool) *CodecInterface_IsTypedEvent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CodecInterface_IsTypedEvent_Call) RunAndReturn(run func(*types.Event) bool) *CodecInterface_IsTypedEvent_Call {
	_c.Call.Return(run)
	return _c
}

// MarshalProtoJSON provides a mock function with given fields: event
func (_m *CodecInterface) MarshalProtoJSON(event proto.Message) (json.RawMessage, error) {
	ret := _m.Called(event)

	if len(ret) == 0 {
		panic("no return value specified for MarshalProtoJSON")
	}

	var r0 json.RawMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(proto.Message) (json.RawMessage, error)); ok {
		return rf(event)
	}
	if rf, ok := ret.Get(0).(func(proto.Message) json.RawMessage); ok {
		r0 = rf(event)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(json.RawMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(proto.Message) error); ok {
		r1 = rf(event)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CodecInterface_MarshalProtoJSON_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarshalProtoJSON'
type CodecInterface_MarshalProtoJSON_Call struct {
	*mock.Call
}

// MarshalProtoJSON is a helper method to define mock.On call
//   - event proto.Message
func (_e *CodecInterface_Expecter) MarshalProtoJSON(event interface{}) *CodecInterface_MarshalProtoJSON_Call {
	return &CodecInterface_MarshalProtoJSON_Call{Call: _e.mock.On("MarshalProtoJSON", event)}
}

func (_c *CodecInterface_MarshalProtoJSON_Call) Run(run func(event proto.Message)) *CodecInterface_MarshalProtoJSON_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(proto.Message))
	})
	return _c
}

func (_c *CodecInterface_MarshalProtoJSON_Call) Return(_a0 json.RawMessage, _a1 error) *CodecInterface_MarshalProtoJSON_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CodecInterface_MarshalProtoJSON_Call) RunAndReturn(run func(proto.Message) (json.RawMessage, error)) *CodecInterface_MarshalProtoJSON_Call {
	_c.Call.Return(run)
	return _c
}

// ParseEvent provides a mock function with given fields: event
func (_m *CodecInterface) ParseEvent(event *types.Event) (proto.Message, error) {
	ret := _m.Called(event)

	if len(ret) == 0 {
		panic("no return value specified for ParseEvent")
	}

	var r0 proto.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(*types.Event) (proto.Message, error)); ok {
		return rf(event)
	}
	if rf, ok := ret.Get(0).(func(*types.Event) proto.Message); ok {
		r0 = rf(event)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(proto.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(*types.Event) error); ok {
		r1 = rf(event)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CodecInterface_ParseEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseEvent'
type CodecInterface_ParseEvent_Call struct {
	*mock.Call
}

// ParseEvent is a helper method to define mock.On call
//   - event *types.Event
func (_e *CodecInterface_Expecter) ParseEvent(event interface{}) *CodecInterface_ParseEvent_Call {
	return &CodecInterface_ParseEvent_Call{Call: _e.mock.On("ParseEvent", event)}
}

func (_c *CodecInterface_ParseEvent_Call) Run(run func(event *types.Event)) *CodecInterface_ParseEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.Event))
	})
	return _c
}

func (_c *CodecInterface_ParseEvent_Call) Return(_a0 proto.Message, _a1 error) *CodecInterface_ParseEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CodecInterface_ParseEvent_Call) RunAndReturn(run func(*types.Event) (proto.Message, error)) *CodecInterface_ParseEvent_Call {
	_c.Call.Return(run)
	return _c
}

// ParseTx provides a mock function with given fields: txBytes
func (_m *CodecInterface) ParseTx(txBytes []byte) (*tx.Tx, error) {
	ret := _m.Called(txBytes)

	if len(ret) == 0 {
		panic("no return value specified for ParseTx")
	}

	var r0 *tx.Tx
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) (*tx.Tx, error)); ok {
		return rf(txBytes)
	}
	if rf, ok := ret.Get(0).(func([]byte) *tx.Tx); ok {
		r0 = rf(txBytes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tx.Tx)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(txBytes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CodecInterface_ParseTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseTx'
type CodecInterface_ParseTx_Call struct {
	*mock.Call
}

// ParseTx is a helper method to define mock.On call
//   - txBytes []byte
func (_e *CodecInterface_Expecter) ParseTx(txBytes interface{}) *CodecInterface_ParseTx_Call {
	return &CodecInterface_ParseTx_Call{Call: _e.mock.On("ParseTx", txBytes)}
}

func (_c *CodecInterface_ParseTx_Call) Run(run func(txBytes []byte)) *CodecInterface_ParseTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *CodecInterface_ParseTx_Call) Return(_a0 *tx.Tx, _a1 error) *CodecInterface_ParseTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CodecInterface_ParseTx_Call) RunAndReturn(run func([]byte) (*tx.Tx, error)) *CodecInterface_ParseTx_Call {
	_c.Call.Return(run)
	return _c
}

// ParseTxMessage provides a mock function with given fields: message
func (_m *CodecInterface) ParseTxMessage(message *codectypes.Any) (proto.Message, error) {
	ret := _m.Called(message)

	if len(ret) == 0 {
		panic("no return value specified for ParseTxMessage")
	}

	var r0 proto.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(*codectypes.Any) (proto.Message, error)); ok {
		return rf(message)
	}
	if rf, ok := ret.Get(0).(func(*codectypes.Any) proto.Message); ok {
		r0 = rf(message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(proto.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(*codectypes.Any) error); ok {
		r1 = rf(message)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CodecInterface_ParseTxMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseTxMessage'
type CodecInterface_ParseTxMessage_Call struct {
	*mock.Call
}

// ParseTxMessage is a helper method to define mock.On call
//   - message *codectypes.Any
func (_e *CodecInterface_Expecter) ParseTxMessage(message interface{}) *CodecInterface_ParseTxMessage_Call {
	return &CodecInterface_ParseTxMessage_Call{Call: _e.mock.On("ParseTxMessage", message)}
}

func (_c *CodecInterface_ParseTxMessage_Call) Run(run func(message *codectypes.Any)) *CodecInterface_ParseTxMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*codectypes.Any))
	})
	return _c
}

func (_c *CodecInterface_ParseTxMessage_Call) Return(_a0 proto.Message, _a1 error) *CodecInterface_ParseTxMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CodecInterface_ParseTxMessage_Call) RunAndReturn(run func(*codectypes.Any) (proto.Message, error)) *CodecInterface_ParseTxMessage_Call {
	_c.Call.Return(run)
	return _c
}

// ParseTxMessages provides a mock function with given fields: txMessages
func (_m *CodecInterface) ParseTxMessages(txMessages []*codectypes.Any) ([]proto.Message, error) {
	ret := _m.Called(txMessages)

	if len(ret) == 0 {
		panic("no return value specified for ParseTxMessages")
	}

	var r0 []proto.Message
	var r1 error
	if rf, ok := ret.Get(0).(func([]*codectypes.Any) ([]proto.Message, error)); ok {
		return rf(txMessages)
	}
	if rf, ok := ret.Get(0).(func([]*codectypes.Any) []proto.Message); ok {
		r0 = rf(txMessages)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]proto.Message)
		}
	}

	if rf, ok := ret.Get(1).(func([]*codectypes.Any) error); ok {
		r1 = rf(txMessages)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CodecInterface_ParseTxMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseTxMessages'
type CodecInterface_ParseTxMessages_Call struct {
	*mock.Call
}

// ParseTxMessages is a helper method to define mock.On call
//   - txMessages []*codectypes.Any
func (_e *CodecInterface_Expecter) ParseTxMessages(txMessages interface{}) *CodecInterface_ParseTxMessages_Call {
	return &CodecInterface_ParseTxMessages_Call{Call: _e.mock.On("ParseTxMessages", txMessages)}
}

func (_c *CodecInterface_ParseTxMessages_Call) Run(run func(txMessages []*codectypes.Any)) *CodecInterface_ParseTxMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]*codectypes.Any))
	})
	return _c
}

func (_c *CodecInterface_ParseTxMessages_Call) Return(_a0 []proto.Message, _a1 error) *CodecInterface_ParseTxMessages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CodecInterface_ParseTxMessages_Call) RunAndReturn(run func([]*codectypes.Any) ([]proto.Message, error)) *CodecInterface_ParseTxMessages_Call {
	_c.Call.Return(run)
	return _c
}

// ParseUntypedEvent provides a mock function with given fields: event
func (_m *CodecInterface) ParseUntypedEvent(event *types.Event) (json.RawMessage, error) {
	ret := _m.Called(event)

	if len(ret) == 0 {
		panic("no return value specified for ParseUntypedEvent")
	}

	var r0 json.RawMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(*types.Event) (json.RawMessage, error)); ok {
		return rf(event)
	}
	if rf, ok := ret.Get(0).(func(*types.Event) json.RawMessage); ok {
		r0 = rf(event)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(json.RawMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(*types.Event) error); ok {
		r1 = rf(event)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CodecInterface_ParseUntypedEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseUntypedEvent'
type CodecInterface_ParseUntypedEvent_Call struct {
	*mock.Call
}

// ParseUntypedEvent is a helper method to define mock.On call
//   - event *types.Event
func (_e *CodecInterface_Expecter) ParseUntypedEvent(event interface{}) *CodecInterface_ParseUntypedEvent_Call {
	return &CodecInterface_ParseUntypedEvent_Call{Call: _e.mock.On("ParseUntypedEvent", event)}
}

func (_c *CodecInterface_ParseUntypedEvent_Call) Run(run func(event *types.Event)) *CodecInterface_ParseUntypedEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.Event))
	})
	return _c
}

func (_c *CodecInterface_ParseUntypedEvent_Call) Return(_a0 json.RawMessage, _a1 error) *CodecInterface_ParseUntypedEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CodecInterface_ParseUntypedEvent_Call) RunAndReturn(run func(*types.Event) (json.RawMessage, error)) *CodecInterface_ParseUntypedEvent_Call {
	_c.Call.Return(run)
	return _c
}

// NewCodecInterface creates a new instance of CodecInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCodecInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *CodecInterface {
	mock := &CodecInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
